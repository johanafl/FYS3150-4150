import numpy as np
import matplotlib.pyplot as plt

def analyze_leglag_data():
    """
    Loads data generated from the program gauss_legendre_quadrature.cpp and
    gauss_laguerre_quadrature.cpp and plots for visualization.
    """

    path_0 = "data_files/legendre_data.txt"
    path_1 = "data_files/laguerre_data.txt"

    # loads data from file
    N_0, error_0, calculated_0, exact_0, comp_time_0 = \
        np.loadtxt(path_0, skiprows=1, unpack=True)

    N_1, error_1, calculated_1, exact_1, comp_time_1 = \
        np.loadtxt(path_1, skiprows=1, unpack=True)


    # time vs error plot
    _, ax = plt.subplots(figsize=(10, 8))

    ax.semilogy(comp_time_0, error_0, label="legendre")
    ax.semilogy(comp_time_1, error_1, label="laguerre")
    
    ax.set_xlabel("computation time [s]", fontsize=30)
    ax.set_ylabel("error", fontsize=30)
    
    ax.legend(fontsize=20)
    ax.grid()
    ax.tick_params(labelsize=30)
    
    plt.show()


def compare_leglag_and_mc_data():
    """
    Reads and compares Laguerre, Legendre, and MC data.
    """
    
    path_0 = "data_files/mc_data.txt"
    path_1 = "data_files/mc_improved_data.txt"
    path_2 = "data_files/legendre_data.txt"
    path_3 = "data_files/laguerre_data.txt"

    # loads data from file
    N_0, error_0, calculated_0, exact_0, comp_time_0, variance_0 = \
        np.loadtxt(path_0, skiprows=1, unpack=True)

    N_1, error_1, calculated_1, exact_1, comp_time_1, variance_1 = \
        np.loadtxt(path_1, skiprows=1, unpack=True)

    N_2, error_2, calculated_2, exact_2, comp_time_2 = \
        np.loadtxt(path_2, skiprows=1, unpack=True)

    N_3, error_3, calculated_3, exact_3, comp_time_3 = \
        np.loadtxt(path_3, skiprows=1, unpack=True)


    # iterations vs error plot
    _, ax = plt.subplots(figsize=(10, 8))

    ax.semilogy(N_2**6, error_2, label="legendre")
    ax.semilogy(N_3**6, error_3, label="laguerre")
    
    # some nasty slicing to account for that we changed the resolution after a
    # period of calculation to save time
    ax.semilogy(N_0[:100:6], error_0[:100:6], color="green")
    ax.semilogy(N_0[96:], error_0[96:], label="mc", color="green")
    ax.semilogy(N_1[:50:6], error_1[:50:6], color="red")
    ax.semilogy(N_1[46:], error_1[46:], label="mc improved", color="red")

    ax.set_ylabel("error", fontsize=25)
    ax.set_xlabel("N", fontsize=25)
    
    ax.legend(fontsize=15)
    ax.grid()
    ax.tick_params(labelsize=30)

    plt.show()

    # iterations vs computation time plot
    _, ax = plt.subplots(figsize=(10, 8))

    ax.plot(N_2**6, comp_time_2, label="legendre")
    ax.plot(N_3**6, comp_time_3, label="laguerre")
    ax.plot(N_0, comp_time_0, label="mc")
    ax.plot(N_1, comp_time_1, label="mc improved")

    ax.set_ylabel("computation time [s]", fontsize=25)
    ax.set_xlabel("N", fontsize=25)
    
    ax.legend(fontsize=15)
    ax.grid()
    ax.tick_params(labelsize=30)

    plt.show()
    

def compare_speeds():
    """
    Speed comparison of 2, 4, 6, 8, 10 threads.
    """
    _, ax = plt.subplots(figsize=(10, 8))


    for i in range(2, 10+1, 2):
        path_0 = "data_files/mc_improved_parallel_" + f"{i}" + "thread_data.txt"

        N_0, error_0, calculated_0, exact_0, comp_time_0, variance_0 = \
            np.loadtxt(path_0, skiprows=1, unpack=True)

        ax.plot(N_0, comp_time_0, label=f"{i} threads")

    
    ax.set_title("computation time", fontsize=25)
    ax.set_xlabel("iterations", fontsize=25)
    ax.set_ylabel("computation time [s]", fontsize=25)
    ax.set_xticklabels(["0", "0", "1e6", "2e6", "3e6", "4e6", "5e6"])
    
    ax.legend(fontsize=15)
    ax.grid()
    ax.tick_params(labelsize=30)

    plt.show()


def analyze_contour_data():
    """
    Reads contour data from file generated by gauss_legendre_quadrature.cpp and
    mc_integration.cpp.
    """

    path_0 = "data_files/legendre_contour_data_high_res.txt"
    path_1 = "data_files/mc_contour_data_high_res.txt"
    paths  = [path_0, path_1]

    for path in paths:
        # loading data
        ranges = np.loadtxt(path, skiprows=1, max_rows=1)
        grid = np.loadtxt(path, skiprows=2)
        
        # scaling grid
        grid = np.log10(grid)
        
        # extracting scope values
        N_start, N_end, dN = ranges[0:3]
        lambda_start, lambda_end, dlambda = ranges[3:]

        # creating scopes and meshgrid 
        N_range      = np.arange(N_start, N_end+dN, dN)
        lambda_range = np.arange(lambda_start, lambda_end+dlambda, dlambda)
        X, Y = np.meshgrid(N_range, lambda_range)

        # extracting the indices of the lowest error
        lambda_min, N_min = np.unravel_index(np.argmin(grid), np.shape(grid))
        print(f"Lowest error (log10): {grid[lambda_min, N_min]}")
        print(f"N: {N_range[N_min]}")
        print(f"lambda: {lambda_range[lambda_min]}")
        print()

        _, ax = plt.subplots(figsize=(8,6))

        mappable = ax.contourf(X, Y, grid)
        ax.set_xlabel(r"$N_g$", fontsize=30)
        ax.set_ylabel(r"$\lambda$", fontsize=30)
        ax.tick_params(labelsize=30)
        
        cbar = plt.colorbar(mappable)
        cbar.set_label(r"$log_{10}$ error", fontsize=40)
        cbar.ax.tick_params(labelsize=30) 
        
        plt.show()


def illustrate_distributions(distribution="uniform"):
    """
    Illustrates how the uniform and exponential distributions overlap with the
    integrand.

    Parameters
    ----------
    distribution : str
        String input of either "uniform" or "exponential".
    """

    x0 = np.linspace(-0.01, -1, 1000)
    x1 = np.linspace(0.01, 1, 1000)

    _, ax = plt.subplots()
    
    ax.plot(x0, np.abs(1/x0), color="black", label="f(x)")
    ax.plot(x1, 1/x1, color="black")

    if distribution == "uniform":
        ax.plot([-1, 1], [10, 10], label="uniform distribution")
        ax.plot([-1, -1], [0, 10.7], linestyle="dashed", alpha=0.8, color="black")
        ax.plot([1, 1], [0, 10.7], linestyle="dashed", alpha=0.8, color="black")

    elif distribution == "exponential":
        lam = 15
        ax.plot(x0, 5*lam*np.exp(-lam*x1), color="orange")
        ax.plot(x1, 5*lam*np.exp(-lam*x1), label="fitted distribution", color="orange")
    
    ax.set_ylim([-0, 20])
    ax.set_xlabel("x", fontsize=30)
    ax.set_ylabel("f(x)", fontsize=30)
    ax.grid()
    ax.tick_params(labelsize=30)
    ax.legend(fontsize=15)
    plt.show()


def variance():
    """
    Plots variance data from mc and mc improved.
    """

    path_0 = "data_files/mc_variance_data.txt"
    path_1 = "data_files/mc_improved_variance_data.txt"

    # loads data
    N_0, error_0, calculated_0, exact_0, comp_time_0, variance_0 = \
        np.loadtxt(path_0, skiprows=1, unpack=True)

    N_1, error_1, calculated_1, exact_1, comp_time_1, variance_1 = \
        np.loadtxt(path_1, skiprows=1, unpack=True)


    _, ax = plt.subplots(figsize=(10, 8))

    ax.semilogy(N_0, variance_0, label="mc", color="green")
    ax.semilogy(N_1, variance_1, label="mc improved", color="red")
    
    ax.set_xlabel("iterations", fontsize=25)
    ax.set_ylabel("variance", fontsize=25)
    
    ax.legend(fontsize=20)
    ax.grid()
    ax.tick_params(labelsize=30)
    
    plt.show()


def parallelization():
    """
    Compares the iterations vs computation time for the parallelized and un-
    parallelized mc.
    """

    path_0 = "data_files/mc_improved_data.txt"
    path_1 = "data_files/mc_improved_parallel_data.txt"
    path_2 = "data_files/mc_improved_not_O3_data.txt"


    N_0, error_0, calculated_0, exact_0, comp_time_0, variance_0 = \
        np.loadtxt(path_0, skiprows=1, unpack=True)

    N_1, error_1, calculated_1, exact_1, comp_time_1, variance_1 = \
        np.loadtxt(path_1, skiprows=1, unpack=True)

    N_2, error_2, calculated_2, exact_2, comp_time_2, variance_2 = \
        np.loadtxt(path_2, skiprows=1, unpack=True)


    _, ax = plt.subplots(figsize=(10, 8))

    ax.plot(N_0, comp_time_0, label="mc improved")
    ax.plot(N_2, comp_time_2, label="mc improved not O3")
    ax.plot(N_1, comp_time_1, label="mc improved parallel")
    
    ax.set_xlabel("iterations", fontsize=25)
    ax.set_ylabel("computation time [s]", fontsize=25)
    
    ax.legend(fontsize=20)
    ax.grid()
    ax.tick_params(labelsize=30)
    
    plt.show()

if __name__ == "__main__":
    # analyze_leglag_data()
    # compare_leglag_and_mc_data()
    # compare_speeds()
    # analyze_contour_data()
    # illustrate_distributions(distribution="uniform")
    # variance()
    parallelization()
    pass